* -> drives implicit enumeration
* => drives implicit reduction
* implicit enumeration allows the compiler to generate more optimal code for a loop
  - better vectorization
  - better abstraction (hiding loop implementation details)
  - looser coupling between components of an algorithm
* <source> -> or => ... -> <mapping>
* <source> -> or => ... => <sink>
* <source> can be any of the following:
  - an aggregate (stream, list, array, other containers)
  - a separate process working as a generator
  - a buffered generator (allowing to enumerate it more than once)
  - an OS process
  - a special stream type (blocking stream, event stream, etc.)
* atomic values are implicitly converted to streams of one element
  - an atomic value is one of: atom, scalar, string, vector, tuple
* some atomic values can be converted to longer streams,
  e.g. string -> stream of bytes (or stream of codepoints)
       vector -> stream of coordinates
* all of the components that take part in a given stream enumeration form a single higher level component
* the compiler can optimize a single component as a whole,
  inlining and eliminating operations as long as the semantics stays the same
* errors encountered during an enumeration flow in a separate channel back to the caller
* the caller may choose to ignore errors (then they propagate to the top of the call stack)
* the caller may choose to setup condition handlers for errors (see Common Lisp conditions; Rust)
* side effects inside an enumeration occur at known synchronization points
* side-effect-less enumeration can be optimizied more aggresively by the compiler
* the language evaluates expressions eagerly, but can support lazy streams
* enumeration can be done sequentially, concurrently, or in parallel -- the interface remains the same


>> Example: Parallel map <<

// map all elements of an array to their respective squares, in parallel
let nums = array(1..100)
let squares_sequential 
         = nums -> fn(x) { x * x } => array()
let squares 
         = parallel(nums) -> fn(x) { x * x } => array()

* That is, the mechanics of enumeration are determined entirely by the source.
  The code shape is independent of the what is going on under the hood.


>> Example: List monad <<

let nums = array(1, 2, 3)
let perms1 = list_monad(nums) => array()  // [(1,), (2,), (3,)]
let perms2 = list_monad(nums, nums) => array()  // [(1,1), (1,2), (1,3), (2,1), (2,2), (2,3), (3,1), (3,2), (3,3)]
let perms3 = list_monad(fn() {
    let x = nums
    let y = nums
    return (x, y)
}) => array()


## Important points of a new language ##

* Controlled side effects and mutability lead to
  1) better abstraction
  2) better optimization opportunities
* Mutable state should be employed locally, for performance goals
* Encoding state in a few established "places" helps make program automatically parallelizable/distributable

* Conditions provide greater flexibility than exceptions and potentially better code reuse
* Standard error propagation mechanism frees the programmer of boiler-plate, helps write code that fails early
* Freeing ordinary code from error handling provides an abstraction that helps in separation of concerns
  (helps getting rid of ad-hoc and hence poor-quality error reporting)

* Generic programming helps in code reuse
* Operator overloading helps keep the syntax under control
* Compiler should be able to reason about types and traits to provide good optimization

* Boilerplate can be eliminated using macros
* Macros don't have to be the same language (think scripting/embedded language)

* Iteration should be a first-class abstraction to provide
  1) conciseness
  2) separation of concerns
  3) performance
