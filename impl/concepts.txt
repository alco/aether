* -> drives implicit enumeration
* => drives implicit reduction
* implicit enumeration allows the compiler to generate more optimal code for a loop
  - better vectorization
  - better abstraction (hiding loop implementation details)
  - looser coupling between components of an algorithm
* <source> -> or => ... -> <mapping>
* <source> -> or => ... => <sink>
* <source> can be any of the following:
  - an aggregate (stream, list, array, other containers)
  - a separate process working as a generator
  - a buffered generator (allowing to enumerate it more than once)
  - an OS process
  - a special stream type (blocking stream, event stream, etc.)
* atomic values are implicitly converted to streams of one element
  - an atomic value is one of: atom, scalar, string, vector, tuple
* some atomic values can be converted to longer streams,
  e.g. string -> stream of bytes (or stream of codepoints)
       vector -> stream of coordinates
* all of the components that take part in a given stream enumeration form a single higher level component
* the compiler can optimize a single component as a whole,
  inlining and eliminating operations as long as the semantics stays the same
* errors encountered during an enumeration flow in a separate channel back to the caller
* the caller may choose to ignore errors (then they propagate to the top of the call stack)
* the caller may choose to setup condition handlers for errors (see Common Lisp conditions; Rust)
* side effects inside an enumeration occur at known synchronization points
* side-effect-less enumeration can be optimizied more aggresively by the compiler
* the language evaluates expressions eagerly, but can support lazy streams
* enumeration can be done sequentially, concurrently, or in parallel -- the interface remains the same


>> Example: Parallel map <<

// map all elements of an array to their respective squares, in parallel
let nums = array(1..100)
let squares_sequential 
         = nums -> fn(x) { x * x } => array()
let squares 
         = parallel(nums) -> fn(x) { x * x } => array()

* That is, the mechanics of enumeration are determined entirely by the source.
  The code shape is independent of the what is going on under the hood.


>> Example: List monad <<

let nums = array(1, 2, 3)
let perms1 = list_monad(nums) => array()  // [(1,), (2,), (3,)]
let perms2 = list_monad(nums, nums) => array()  // [(1,1), (1,2), (1,3), (2,1), (2,2), (2,3), (3,1), (3,2), (3,3)]
let perms3 = list_monad(fn() {
    let x = nums
    let y = nums
    return (x, y)
}) => array()
